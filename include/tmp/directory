// -*- C++ -*-
//
// SPDX-FileCopyrightText: (c) 2024 Ilya Andreev <bugdealer@icloud.com>
// SPDX-License-Identifier: MIT

#ifndef TMP_DIRECTORY_H
#define TMP_DIRECTORY_H

#include <cstddef>
#include <filesystem>
#include <string_view>
#include <system_error>
#include <utility>

namespace tmp {

namespace detail {
extern "C++" std::filesystem::path::string_type
create_directory(std::string_view prefix, std::error_code& ec);
extern "C++" void
remove_all(const std::filesystem::path::string_type& path) noexcept;
}    // namespace detail

/// tmp::directory is a smart handle that manages a temporary directory,
/// ensuring its recursive deletion when the handle goes out of scope
///
/// When a tmp::directory object is created, it generates a unique temporary
/// directory in the current user's temporary directory
///
/// The temporary directory is deleted when either of the following happens:
/// - the tmp::directory object is destroyed
/// - the tmp::directory object is assigned another directory using operator=
///
/// The example below demonstrates a usage of a tmp::directory object to run
/// a subprocess within it and archive its logs; when the function
/// returns, the temporary directory is recursively deleted:
///
/// @code{.cpp}
///   #include <tmp/directory>
///
///   auto func() {
///     auto tmpdir = tmp::directory("org.example.product");
///     process::exec(executable, args, tmpdir);
///
///     return archive::glob(tmpdir, "*.log");
///
///     // The temporary directory is deleted recursively when the
///     // tmp::directory object goes out of scope
///   }
/// @endcode
class directory {
public:
  /// Creates a unique directory in the current user's temporary directory
  /// @param prefix A prefix to add to the temporary directory name
  /// @throws std::filesystem::filesystem_error if cannot create a directory
  /// @throws std::invalid_argument if the prefix contains a directory separator
  explicit directory(std::string_view prefix = "")
      : pathobject() {
    std::error_code ec;
    auto result = detail::create_directory(prefix, ec);
    if (ec) {
      throw std::filesystem::filesystem_error(
          "Cannot create a temporary directory", ec);
    }
    pathobject = std::filesystem::path(std::move(result));
  }

  directory(const directory&)            = delete;
  directory& operator=(const directory&) = delete;

  /// Moves the ownership of the directory managed by `other` to a new handle
  /// @note After the move, `other` is not associated with a directory
  /// @param other Another directory that will be moved from
  directory(directory&& other) noexcept
      : pathobject(std::exchange(other.pathobject, std::filesystem::path())) {}

  /// Deletes the managed temporary directory, then moves the ownership
  /// of the directory managed by `other` to `this`
  /// @note After the assignment, `other` is not associated with a directory
  /// @param other Another directory that will be moved from
  /// @returns `*this`
  directory& operator=(directory&& other) noexcept {
    detail::remove_all(pathobject.native());
    pathobject = std::exchange(other.pathobject, std::filesystem::path());

    return *this;
  }

  /// Returns the path of this directory
  /// @returns The canonical path of this directory
  operator const std::filesystem::path&() const noexcept {
    return pathobject;
  }

  /// Returns the path of this directory
  /// @returns The canonical path of this directory
  const std::filesystem::path& path() const noexcept {
    return pathobject;
  }

  /// Concatenates this directory path with a given path name
  /// @param source A path name
  /// @returns The result of path concatenation
  std::filesystem::path operator/(const std::filesystem::path& source) const {
    return path() / source;
  }

  /// Deletes this directory recursively
  ~directory() noexcept {
    detail::remove_all(pathobject.native());
  }

private:
  /// This directory path
  std::filesystem::path pathobject;
};
}    // namespace tmp

#endif    // TMP_DIRECTORY_H

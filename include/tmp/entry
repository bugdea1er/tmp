#ifndef TMP_ENTRY_H
#define TMP_ENTRY_H

#include <tmp/export>

#include <filesystem>
#include <system_error>
#include <utility>

namespace tmp {

/// tmp::entry is a smart handle that owns and manages a temporary path and
/// deletes it recursively when this handle goes out of scope
///
/// The managed path is deleted of when either of the following happens:
/// - the managing tmp::entry object is destroyed
/// - the managing tmp::entry object is assigned another path via operator=
///
/// Subclasses must provide a path and an open handle to the entry constructor;
/// entry closes the handle before deleting the managed path
class TMP_EXPORT entry {
public:
/// Implementation-defined handle type to the temporary entry
#if defined(_WIN32)
  using native_handle_type = void*;    // HANDLE
#elif __has_include(<unistd.h>)
  using native_handle_type = int;    // POSIX file descriptor
#else
#error "Target platform not supported"
#endif

  /// Returns the managed path
  /// @returns The full path this entry manages
  operator const std::filesystem::path&() const noexcept;

  /// Returns the managed path
  /// @returns The full path this entry manages
  const std::filesystem::path& path() const noexcept;

  /// Returns an implementation-defined handle to this entry
  /// @returns The underlying implementation-defined handle
  native_handle_type native_handle() const noexcept;

  /// Moves the managed path recursively to a given target, releasing
  /// ownership of the managed path; behaves like `std::filesystem::rename`
  /// even when moving between filesystems
  /// @note The target path parent is created when this function is called
  /// @param[in] to A path to the target file or directory
  /// @throws std::filesystem::filesystem_error if cannot move the owned path
  void move(const std::filesystem::path& to);

  /// Moves the managed path recursively to a given target, releasing
  /// ownership of the managed path; behaves like `std::filesystem::rename`
  /// even when moving between filesystems
  /// @note The target path parent is created when this function is called
  /// @param[in]  to A path to the target file or directory
  /// @param[out] ec Parameter for error reporting
  void move(const std::filesystem::path& to, std::error_code& ec);

  /// Deletes the managed path recursively and closes its handle
  virtual ~entry() noexcept;

  entry(const entry&) = delete;               ///< not CopyConstructible
  entry& operator=(const entry&) = delete;    ///< not CopyAssignable

  bool operator==(const entry& rhs) const noexcept;    ///< EqualityComparable
  bool operator!=(const entry& rhs) const noexcept;
  bool operator<(const entry& rhs) const noexcept;    ///< LessThanComparable
  bool operator>(const entry& rhs) const noexcept;
  bool operator<=(const entry& rhs) const noexcept;
  bool operator>=(const entry& rhs) const noexcept;

protected:
  /// Creates a temporary entry which owns the given path and handle
  /// @param[in] path   A path to manage
  /// @param[in] handle An implementation-defined handle to this entry
  explicit entry(std::filesystem::path path, native_handle_type handle);

  /// Creates a temporary entry which owns the given path and handle
  /// @param[in] handle A pair of a path and a handle to manage
  explicit entry(std::pair<std::filesystem::path, native_handle_type> handle);

  entry(entry&&) noexcept;               ///< MoveConstructible
  entry& operator=(entry&&) noexcept;    ///< MoveAssignable

private:
  /// The managed path
  std::filesystem::path pathobject;

  /// Implementation-defined handle to this entry
  native_handle_type handle;
};
}    // namespace tmp

/// The template specialization of `std::hash` for `tmp::entry`
template<> struct std::hash<tmp::entry> : std::hash<std::filesystem::path> {};

#endif    // TMP_ENTRY_H

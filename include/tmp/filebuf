// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef TMP_FILEBUF_H
#define TMP_FILEBUF_H

#include <streambuf>
#include <string>

namespace tmp {

/// `tmp::basic_filebuf` is a stream buffer whose associated character sequence
/// is a file; both the input and the output sequences are associated with
/// the same file, and a joint file position is maintained for both operations
///
/// The reason we implement this here rather than using the standard
/// `std::filebuf` is that the standard does not provide a way to use
/// an existing open file in a file buffer, and does not even report errors when
/// opening a file fails
///
/// This is a modified libc++`std::basic_filebuf`; check out the LICENSE file at
/// https://github.com/llvm/llvm-project/blob/main/libcxx/LICENSE.TXT
///
/// Modifications include:
/// - removed unused `open` methods for paths
/// - added `open` method for opening an existing `std::FILE*`
/// NOLINTBEGIN
template<class charT, class traits = std::char_traits<charT>>
class basic_filebuf : public std::basic_streambuf<charT, traits> {
public:
  using char_type = charT;
  using traits_type = traits;
  using int_type = typename traits_type::int_type;
  using pos_type = typename traits_type::pos_type;
  using off_type = typename traits_type::off_type;
  using state_type = typename traits_type::state_type;

  /// Implementation-defined handle type to the file
#if defined(_WIN32)
  using native_handle_type = void*;    // HANDLE
#elif __has_include(<unistd.h>)
  using native_handle_type = int;    // POSIX file descriptor
#else
#error "Target platform not supported"
#endif

  /// Constructs a file buffer
  /// @param file An open file
  /// @param mode The file opening mode
  basic_filebuf(std::FILE* file, std::ios::openmode mode);

  /// Checks whether the associated file is open
  /// @returns `true` if the associated file is open, `false` otherwise
  bool is_open() const;

  /// Returns an implementation-defined handle to this entry
  /// @returns The underlying implementation-defined handle
  native_handle_type native_handle() const noexcept {
#if defined(_WIN32)
    return std::__filebuf_windows_native_handle(__file_);
#elif __has_include(<unistd.h>)
    return fileno(__file_);
#else
#error "Target platform not supported"
#endif
  }

  /// Flushes the put area buffer and closes the associated file
  /// @returns `this` file buffer, or a null pointer on failure
  basic_filebuf* close();

  /// Swaps two file buffers
  /// @param rhs File buffer to swap with
  void swap(basic_filebuf& rhs);

  /// Closes the file if it is open
  ~basic_filebuf() noexcept override;

  basic_filebuf(basic_filebuf&&) noexcept;         ///< MoveConstructible
  basic_filebuf& operator=(basic_filebuf&&);       ///< MoveAssignable
  basic_filebuf(const basic_filebuf&) = delete;    ///< not CopyConstructible
  basic_filebuf&
  operator=(const basic_filebuf&) = delete;    ///< not CopyAssignable

protected:
  /// Reads more data into the input area
  /// @returns The current character of the get area, or `traits::eof()` on
  /// failure
  int_type underflow() override;

  /// Backs out the input sequence to unget a character
  /// @param c The character to put back
  /// @returns `c`, or `traits::eof()` on failure
  int_type pbackfail(int_type c = traits_type::eof()) override;

  /// Writes characters to the associated file from the put area
  /// @returns `traits::not_eof(c)`, or `traits::eof()` on failure
  int_type overflow(int_type c = traits_type::eof()) override;

  /// Provides user-supplied buffer or turns this object unbuffered
  /// @param s Pointer to the first `charT` in the provided buffer or `nullptr`
  /// @param n The number of `charT` elements in the provided buffer or zero
  /// @returns `this` file buffer
  basic_filebuf* setbuf(char_type* s, std::streamsize n) override;

  /// Repositions the file pointer, if possible, using relative addressing
  /// @param off   Relative position to set the position indicator to
  /// @param dir   Defines base position to apply the relative offset to
  /// @param which Defines which of the input and/or output sequences to affect
  /// @returns The resulting file position, or `pos_type(off_type(-1))` on
  /// failure
  pos_type seekoff(off_type off, std::ios::seekdir dir,
                   std::ios::openmode which) override;

  /// Repositions the file pointer, if possible, using absolute addressing
  /// @param sp    The file position obtained earlier on the same file
  /// @param which Defines which of the input and/or output sequences to affect
  /// @returns `sp` on success or `pos_type(off_type(-1))` on failure
  pos_type seekpos(pos_type sp, std::ios::openmode which) override;

  /// Writes characters to the associated file from the put area
  /// @returns `0` in case of success, `-1` in case of failure
  int sync() override;

  /// Changes the associated locale
  /// @param loc The locale to imbue the stream with
  void imbue(const std::locale& loc) override;

private:
  char* __extbuf_;
  const char* __extbufnext_;
  const char* __extbufend_;
  char __extbuf_min_[8];
  size_t __ebs_;
  char_type* __intbuf_;
  size_t __ibs_;
  FILE* __file_;
  const std::codecvt<char_type, char, state_type>* __cv_;
  state_type __st_;
  state_type __st_last_;
  std::ios_base::openmode __om_;
  std::ios_base::openmode __cm_;
  bool __owns_eb_;
  bool __owns_ib_;
  bool __always_noconv_;

  static int __fseek(FILE* __file, pos_type __offset, int __whence);
  static pos_type __ftell(FILE* __file);
  bool __read_mode();
  void __write_mode();

  /// Opens a file and configures it as the associated character sequence
  /// @param file An open file
  /// @param mode The file opening mode
  /// @returns `this` file buffer, or a null pointer on failure
  basic_filebuf* open(std::FILE* file, std::ios::openmode mode);
};

using filebuf = basic_filebuf<char>;
using wfilebuf = basic_filebuf<wchar_t>;

template<class charT, class traits>
basic_filebuf<charT, traits>::basic_filebuf(std::FILE* file,
                                            std::ios::openmode mode)
    : __extbuf_(nullptr),
      __extbufnext_(nullptr),
      __extbufend_(nullptr),
      __ebs_(0),
      __intbuf_(nullptr),
      __ibs_(0),
      __file_(nullptr),
      __cv_(nullptr),
      __st_(),
      __st_last_(),
      __om_(0),
      __cm_(0),
      __owns_eb_(false),
      __owns_ib_(false),
      __always_noconv_(false) {
  if (std::has_facet<std::codecvt<char_type, char, state_type>>(
          this->getloc())) {
    __cv_ = &std::use_facet<std::codecvt<char_type, char, state_type>>(
        this->getloc());
    __always_noconv_ = __cv_->always_noconv();
  }
  setbuf(nullptr, 4096);

  open(file, mode);
}

template<class charT, class traits>
basic_filebuf<charT, traits>::basic_filebuf(basic_filebuf&& __rhs) noexcept
    : std::basic_streambuf<charT, traits>(__rhs) {
  if (__rhs.__extbuf_ == __rhs.__extbuf_min_) {
    __extbuf_ = __extbuf_min_;
    __extbufnext_ = __extbuf_ + (__rhs.__extbufnext_ - __rhs.__extbuf_);
    __extbufend_ = __extbuf_ + (__rhs.__extbufend_ - __rhs.__extbuf_);
  } else {
    __extbuf_ = __rhs.__extbuf_;
    __extbufnext_ = __rhs.__extbufnext_;
    __extbufend_ = __rhs.__extbufend_;
  }
  __ebs_ = __rhs.__ebs_;
  __intbuf_ = __rhs.__intbuf_;
  __ibs_ = __rhs.__ibs_;
  __file_ = __rhs.__file_;
  __cv_ = __rhs.__cv_;
  __st_ = __rhs.__st_;
  __st_last_ = __rhs.__st_last_;
  __om_ = __rhs.__om_;
  __cm_ = __rhs.__cm_;
  __owns_eb_ = __rhs.__owns_eb_;
  __owns_ib_ = __rhs.__owns_ib_;
  __always_noconv_ = __rhs.__always_noconv_;
  if (__rhs.pbase()) {
    if (__rhs.pbase() == __rhs.__intbuf_) {
      this->setp(__intbuf_, __intbuf_ + (__rhs.epptr() - __rhs.pbase()));
    } else {
      this->setp((char_type*)__extbuf_,
                 (char_type*)__extbuf_ + (__rhs.epptr() - __rhs.pbase()));
    }
    this->__pbump(__rhs.pptr() - __rhs.pbase());
  } else if (__rhs.eback()) {
    if (__rhs.eback() == __rhs.__intbuf_) {
      this->setg(__intbuf_, __intbuf_ + (__rhs.gptr() - __rhs.eback()),
                 __intbuf_ + (__rhs.egptr() - __rhs.eback()));
    } else {
      this->setg((char_type*)__extbuf_,
                 (char_type*)__extbuf_ + (__rhs.gptr() - __rhs.eback()),
                 (char_type*)__extbuf_ + (__rhs.egptr() - __rhs.eback()));
    }
  }
  __rhs.__extbuf_ = nullptr;
  __rhs.__extbufnext_ = nullptr;
  __rhs.__extbufend_ = nullptr;
  __rhs.__ebs_ = 0;
  __rhs.__intbuf_ = 0;
  __rhs.__ibs_ = 0;
  __rhs.__file_ = nullptr;
  __rhs.__st_ = state_type();
  __rhs.__st_last_ = state_type();
  __rhs.__om_ = 0;
  __rhs.__cm_ = 0;
  __rhs.__owns_eb_ = false;
  __rhs.__owns_ib_ = false;
  __rhs.setg(0, 0, 0);
  __rhs.setp(0, 0);
}

template<class charT, class traits>
inline basic_filebuf<charT, traits>&
basic_filebuf<charT, traits>::operator=(basic_filebuf&& __rhs) {
  close();
  swap(__rhs);
  return *this;
}

template<class charT, class traits>
basic_filebuf<charT, traits>::~basic_filebuf() noexcept {
  try {
    close();
  } catch (...) {
    // do nothing
  }
  if (__owns_eb_) {
    delete[] __extbuf_;
  }
  if (__owns_ib_) {
    delete[] __intbuf_;
  }
}

template<class charT, class traits>
void basic_filebuf<charT, traits>::swap(basic_filebuf& __rhs) {
  std::basic_streambuf<char_type, traits_type>::swap(__rhs);
  if (__extbuf_ != __extbuf_min_ && __rhs.__extbuf_ != __rhs.__extbuf_min_) {
    // Neither *this nor __rhs uses the small buffer, so we can simply swap the
    // pointers.
    std::swap(__extbuf_, __rhs.__extbuf_);
    std::swap(__extbufnext_, __rhs.__extbufnext_);
    std::swap(__extbufend_, __rhs.__extbufend_);
  } else {
    ptrdiff_t __ln = __extbufnext_ ? __extbufnext_ - __extbuf_ : 0;
    ptrdiff_t __le = __extbufend_ ? __extbufend_ - __extbuf_ : 0;
    ptrdiff_t __rn =
        __rhs.__extbufnext_ ? __rhs.__extbufnext_ - __rhs.__extbuf_ : 0;
    ptrdiff_t __re =
        __rhs.__extbufend_ ? __rhs.__extbufend_ - __rhs.__extbuf_ : 0;
    if (__extbuf_ == __extbuf_min_ && __rhs.__extbuf_ != __rhs.__extbuf_min_) {
      // *this uses the small buffer, but __rhs doesn't.
      __extbuf_ = __rhs.__extbuf_;
      __rhs.__extbuf_ = __rhs.__extbuf_min_;
      std::memmove(__rhs.__extbuf_min_, __extbuf_min_, sizeof(__extbuf_min_));
    } else if (__extbuf_ != __extbuf_min_ &&
               __rhs.__extbuf_ == __rhs.__extbuf_min_) {
      // *this doesn't use the small buffer, but __rhs does.
      __rhs.__extbuf_ = __extbuf_;
      __extbuf_ = __extbuf_min_;
      std::memmove(__extbuf_min_, __rhs.__extbuf_min_, sizeof(__extbuf_min_));
    } else {
      // Both *this and __rhs use the small buffer.
      char __tmp[sizeof(__extbuf_min_)];
      std::memmove(__tmp, __extbuf_min_, sizeof(__extbuf_min_));
      std::memmove(__extbuf_min_, __rhs.__extbuf_min_, sizeof(__extbuf_min_));
      std::memmove(__rhs.__extbuf_min_, __tmp, sizeof(__extbuf_min_));
    }
    __extbufnext_ = __extbuf_ + __rn;
    __extbufend_ = __extbuf_ + __re;
    __rhs.__extbufnext_ = __rhs.__extbuf_ + __ln;
    __rhs.__extbufend_ = __rhs.__extbuf_ + __le;
  }
  std::swap(__ebs_, __rhs.__ebs_);
  std::swap(__intbuf_, __rhs.__intbuf_);
  std::swap(__ibs_, __rhs.__ibs_);
  std::swap(__file_, __rhs.__file_);
  std::swap(__cv_, __rhs.__cv_);
  std::swap(__st_, __rhs.__st_);
  std::swap(__st_last_, __rhs.__st_last_);
  std::swap(__om_, __rhs.__om_);
  std::swap(__cm_, __rhs.__cm_);
  std::swap(__owns_eb_, __rhs.__owns_eb_);
  std::swap(__owns_ib_, __rhs.__owns_ib_);
  std::swap(__always_noconv_, __rhs.__always_noconv_);
  if (this->eback() == (char_type*)__rhs.__extbuf_min_) {
    ptrdiff_t __n = this->gptr() - this->eback();
    ptrdiff_t __e = this->egptr() - this->eback();
    this->setg((char_type*)__extbuf_min_, (char_type*)__extbuf_min_ + __n,
               (char_type*)__extbuf_min_ + __e);
  } else if (this->pbase() == (char_type*)__rhs.__extbuf_min_) {
    ptrdiff_t __n = this->pptr() - this->pbase();
    ptrdiff_t __e = this->epptr() - this->pbase();
    this->setp((char_type*)__extbuf_min_, (char_type*)__extbuf_min_ + __e);
    this->__pbump(__n);
  }
  if (__rhs.eback() == (char_type*)__extbuf_min_) {
    ptrdiff_t __n = __rhs.gptr() - __rhs.eback();
    ptrdiff_t __e = __rhs.egptr() - __rhs.eback();
    __rhs.setg((char_type*)__rhs.__extbuf_min_,
               (char_type*)__rhs.__extbuf_min_ + __n,
               (char_type*)__rhs.__extbuf_min_ + __e);
  } else if (__rhs.pbase() == (char_type*)__extbuf_min_) {
    ptrdiff_t __n = __rhs.pptr() - __rhs.pbase();
    ptrdiff_t __e = __rhs.epptr() - __rhs.pbase();
    __rhs.setp((char_type*)__rhs.__extbuf_min_,
               (char_type*)__rhs.__extbuf_min_ + __e);
    __rhs.__pbump(__n);
  }
}

template<class charT, class traits>
inline _LIBCPP_HIDE_FROM_ABI void swap(basic_filebuf<charT, traits>& __x,
                                       basic_filebuf<charT, traits>& __y) {
  __x.swap(__y);
}

template<class charT, class traits>
inline bool basic_filebuf<charT, traits>::is_open() const {
  return __file_ != nullptr;
}

template<class charT, class traits>
inline basic_filebuf<charT, traits>*
basic_filebuf<charT, traits>::open(std::FILE* file, std::ios::openmode mode) {
  basic_filebuf<charT, traits>* __rt = nullptr;
  if (__file_ == nullptr) {
    __rt = this;
    __file_ = file;
    if (__file_) {
      __om_ = mode;
      if (mode & std::ios_base::ate) {
        if (fseek(__file_, 0, SEEK_END)) {
          fclose(__file_);
          __file_ = nullptr;
          __rt = nullptr;
        }
      }
    } else {
      __rt = nullptr;
    }
  }
  return __rt;
}

template<class charT, class traits>
basic_filebuf<charT, traits>* basic_filebuf<charT, traits>::close() {
  basic_filebuf<charT, traits>* __rt = nullptr;
  if (__file_) {
    __rt = this;
    std::unique_ptr<FILE, int (*)(FILE*)> __h(__file_, fclose);
    if (sync()) {
      __rt = nullptr;
    }
    if (fclose(__h.release())) {
      __rt = nullptr;
    }
    __file_ = nullptr;
    setbuf(0, 0);
  }
  return __rt;
}

template<class charT, class traits>
typename basic_filebuf<charT, traits>::int_type
basic_filebuf<charT, traits>::underflow() {
  if (__file_ == nullptr) {
    return traits_type::eof();
  }
  bool __initial = __read_mode();
  char_type __1buf;
  if (this->gptr() == nullptr) {
    this->setg(&__1buf, &__1buf + 1, &__1buf + 1);
  }
  const size_t __unget_sz =
      __initial ? 0 : std::min<size_t>((this->egptr() - this->eback()) / 2, 4);
  int_type __c = traits_type::eof();
  if (this->gptr() == this->egptr()) {
    std::memmove(this->eback(), this->egptr() - __unget_sz,
                 __unget_sz * sizeof(char_type));
    if (__always_noconv_) {
      size_t __nmemb =
          static_cast<size_t>(this->egptr() - this->eback() - __unget_sz);
      __nmemb = ::fread(this->eback() + __unget_sz, 1, __nmemb, __file_);
      if (__nmemb != 0) {
        this->setg(this->eback(), this->eback() + __unget_sz,
                   this->eback() + __unget_sz + __nmemb);
        __c = traits_type::to_int_type(*this->gptr());
      }
    } else {
      if (__extbufend_ != __extbufnext_) {
        _LIBCPP_ASSERT_NON_NULL(__extbufnext_ != nullptr,
                                "underflow moving from nullptr");
        _LIBCPP_ASSERT_NON_NULL(__extbuf_ != nullptr,
                                "underflow moving into nullptr");
        std::memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);
      }
      __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);
      __extbufend_ =
          __extbuf_ +
          (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);
      size_t __nmemb =
          std::min(static_cast<size_t>(__ibs_ - __unget_sz),
                   static_cast<size_t>(__extbufend_ - __extbufnext_));
      std::codecvt_base::result __r;
      __st_last_ = __st_;
      size_t __nr =
          fread((void*)const_cast<char*>(__extbufnext_), 1, __nmemb, __file_);
      if (__nr != 0) {
        if (!__cv_) {
          std::__throw_bad_cast();
        }

        __extbufend_ = __extbufnext_ + __nr;
        char_type* __inext;
        __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,
                        this->eback() + __unget_sz, this->eback() + __ibs_,
                        __inext);
        if (__r == std::codecvt_base::noconv) {
          this->setg((char_type*)__extbuf_, (char_type*)__extbuf_,
                     (char_type*)const_cast<char*>(__extbufend_));
          __c = traits_type::to_int_type(*this->gptr());
        } else if (__inext != this->eback() + __unget_sz) {
          this->setg(this->eback(), this->eback() + __unget_sz, __inext);
          __c = traits_type::to_int_type(*this->gptr());
        }
      }
    }
  } else {
    __c = traits_type::to_int_type(*this->gptr());
  }
  if (this->eback() == &__1buf) {
    this->setg(nullptr, nullptr, nullptr);
  }
  return __c;
}

template<class charT, class traits>
typename basic_filebuf<charT, traits>::int_type
basic_filebuf<charT, traits>::pbackfail(int_type c) {
  if (__file_ && this->eback() < this->gptr()) {
    if (traits_type::eq_int_type(c, traits_type::eof())) {
      this->gbump(-1);
      return traits_type::not_eof(c);
    }
    if ((__om_ & std::ios_base::out) ||
        traits_type::eq(traits_type::to_char_type(c), this->gptr()[-1])) {
      this->gbump(-1);
      *this->gptr() = traits_type::to_char_type(c);
      return c;
    }
  }
  return traits_type::eof();
}

template<class charT, class traits>
typename basic_filebuf<charT, traits>::int_type
basic_filebuf<charT, traits>::overflow(int_type c) {
  if (__file_ == nullptr) {
    return traits_type::eof();
  }
  __write_mode();
  char_type __1buf;
  char_type* __pb_save = this->pbase();
  char_type* __epb_save = this->epptr();
  if (!traits_type::eq_int_type(c, traits_type::eof())) {
    if (this->pptr() == nullptr) {
      this->setp(&__1buf, &__1buf + 1);
    }
    *this->pptr() = traits_type::to_char_type(c);
    this->pbump(1);
  }
  if (this->pptr() != this->pbase()) {
    if (__always_noconv_) {
      size_t __nmemb = static_cast<size_t>(this->pptr() - this->pbase());
      if (std::fwrite(this->pbase(), sizeof(char_type), __nmemb, __file_) !=
          __nmemb) {
        return traits_type::eof();
      }
    } else {
      char* __extbe = __extbuf_;
      std::codecvt_base::result __r;
      do {
        if (!__cv_) {
          std::__throw_bad_cast();
        }

        const char_type* __e;
        __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e, __extbuf_,
                         __extbuf_ + __ebs_, __extbe);
        if (__e == this->pbase()) {
          return traits_type::eof();
        }
        if (__r == std::codecvt_base::noconv) {
          size_t __nmemb = static_cast<size_t>(this->pptr() - this->pbase());
          if (std::fwrite(this->pbase(), 1, __nmemb, __file_) != __nmemb) {
            return traits_type::eof();
          }
        } else if (__r == std::codecvt_base::ok ||
                   __r == std::codecvt_base::partial) {
          size_t __nmemb = static_cast<size_t>(__extbe - __extbuf_);
          if (fwrite(__extbuf_, 1, __nmemb, __file_) != __nmemb) {
            return traits_type::eof();
          }
          if (__r == std::codecvt_base::partial) {
            this->setp(const_cast<char_type*>(__e), this->pptr());
            this->__pbump(this->epptr() - this->pbase());
          }
        } else {
          return traits_type::eof();
        }
      } while (__r == std::codecvt_base::partial);
    }
    this->setp(__pb_save, __epb_save);
  }
  return traits_type::not_eof(c);
}

template<class charT, class traits>
basic_filebuf<charT, traits>*
basic_filebuf<charT, traits>::setbuf(char_type* s, std::streamsize n) {
  this->setg(nullptr, nullptr, nullptr);
  this->setp(nullptr, nullptr);
  if (__owns_eb_) {
    delete[] __extbuf_;
  }
  if (__owns_ib_) {
    delete[] __intbuf_;
  }
  __ebs_ = n;
  if (__ebs_ > sizeof(__extbuf_min_)) {
    if (__always_noconv_ && s) {
      __extbuf_ = (char*)s;
      __owns_eb_ = false;
    } else {
      __extbuf_ = new char[__ebs_];
      __owns_eb_ = true;
    }
  } else {
    __extbuf_ = __extbuf_min_;
    __ebs_ = sizeof(__extbuf_min_);
    __owns_eb_ = false;
  }
  if (!__always_noconv_) {
    __ibs_ = std::max<std::streamsize>(n, sizeof(__extbuf_min_));
    if (s && __ibs_ > sizeof(__extbuf_min_)) {
      __intbuf_ = s;
      __owns_ib_ = false;
    } else {
      __intbuf_ = new char_type[__ibs_];
      __owns_ib_ = true;
    }
  } else {
    __ibs_ = 0;
    __intbuf_ = nullptr;
    __owns_ib_ = false;
  }
  return this;
}

template<class charT, class traits>
typename basic_filebuf<charT, traits>::pos_type
basic_filebuf<charT, traits>::seekoff(off_type off, std::ios_base::seekdir dir,
                                      std::ios_base::openmode) {
  if (!__cv_) {
    std::__throw_bad_cast();
  }

  int __width = __cv_->encoding();
  if (__file_ == nullptr || (__width <= 0 && off != 0) || sync()) {
    return pos_type(off_type(-1));
  }
  // __width > 0 || __off == 0
  int __whence;
  switch (dir) {
  case std::ios_base::beg:
    __whence = SEEK_SET;
    break;
  case std::ios_base::cur:
    __whence = SEEK_CUR;
    break;
  case std::ios_base::end:
    __whence = SEEK_END;
    break;
  default:
    return pos_type(off_type(-1));
  }
#if defined(_LIBCPP_HAS_NO_OFF_T_FUNCTIONS)
  if (fseek(__file_, __width > 0 ? __width * __off : 0, __whence)) {
    return pos_type(off_type(-1));
  }
  pos_type __r = ftell(__file_);
#else
  if (::fseeko(__file_, __width > 0 ? __width * off : 0, __whence)) {
    return pos_type(off_type(-1));
  }
  pos_type __r = ftello(__file_);
#endif
  __r.state(__st_);
  return __r;
}

template<class _CharT, class _Traits>
int basic_filebuf<_CharT, _Traits>::__fseek(FILE* __file, pos_type __offset,
                                            int __whence) {
#if defined(_WIN32)
  return _fseeki64(__file, __offset, __whence);
#else
  return ::fseeko(__file, __offset, __whence);
#endif
}

template<class _CharT, class _Traits>
typename basic_filebuf<_CharT, _Traits>::pos_type
basic_filebuf<_CharT, _Traits>::__ftell(FILE* __file) {
#if defined(_WIN32)
  return _ftelli64(__file);
#else
  return ftello(__file);
#endif
}

template<class charT, class traits>
typename basic_filebuf<charT, traits>::pos_type
basic_filebuf<charT, traits>::seekpos(pos_type sp, std::ios::openmode) {
  if (__file_ == nullptr || sync()) {
    return pos_type(off_type(-1));
  }
  if (__fseek(__file_, sp, SEEK_SET)) {
    return pos_type(off_type(-1));
  }
  __st_ = sp.state();
  return sp;
}

template<class charT, class traits> int basic_filebuf<charT, traits>::sync() {
  if (__file_ == nullptr) {
    return 0;
  }
  if (!__cv_) {
    throw std::bad_cast();
  }

  if (__cm_ & std::ios_base::out) {
    if (this->pptr() != this->pbase()) {
      if (overflow() == traits_type::eof()) {
        return -1;
      }
    }
    std::codecvt_base::result __r;
    do {
      char* __extbe;
      __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);
      size_t __nmemb = static_cast<size_t>(__extbe - __extbuf_);
      if (fwrite(__extbuf_, 1, __nmemb, __file_) != __nmemb) {
        return -1;
      }
    } while (__r == std::codecvt_base::partial);
    if (__r == std::codecvt_base::error) {
      return -1;
    }
    if (fflush(__file_)) {
      return -1;
    }
  } else if (__cm_ & std::ios_base::in) {
    off_type __c;
    state_type __state = __st_last_;
    bool __update_st = false;
    if (__always_noconv_) {
      __c = this->egptr() - this->gptr();
    } else {
      int __width = __cv_->encoding();
      __c = __extbufend_ - __extbufnext_;
      if (__width > 0) {
        __c += __width * (this->egptr() - this->gptr());
      } else {
        if (this->gptr() != this->egptr()) {
          const int __off = __cv_->length(__state, __extbuf_, __extbufnext_,
                                          this->gptr() - this->eback());
          __c += __extbufnext_ - __extbuf_ - __off;
          __update_st = true;
        }
      }
    }
    if (__fseek(__file_, -__c, SEEK_CUR)) {
      return -1;
    }
    if (__update_st) {
      __st_ = __state;
    }
    __extbufnext_ = __extbufend_ = __extbuf_;
    this->setg(nullptr, nullptr, nullptr);
    __cm_ = 0;
  }
  return 0;
}

template<class charT, class traits>
void basic_filebuf<charT, traits>::imbue(const std::locale& loc) {
  sync();
  __cv_ = &std::use_facet<std::codecvt<char_type, char, state_type>>(loc);
  bool __old_anc = __always_noconv_;
  __always_noconv_ = __cv_->always_noconv();
  if (__old_anc != __always_noconv_) {
    this->setg(nullptr, nullptr, nullptr);
    this->setp(nullptr, nullptr);
    // invariant, char_type is char, else we couldn't get here
    if (__always_noconv_)    // need to dump __intbuf_
    {
      if (__owns_eb_) {
        delete[] __extbuf_;
      }
      __owns_eb_ = __owns_ib_;
      __ebs_ = __ibs_;
      __extbuf_ = (char*)__intbuf_;
      __ibs_ = 0;
      __intbuf_ = nullptr;
      __owns_ib_ = false;
    } else    // need to obtain an __intbuf_.
    {         // If __extbuf_ is user-supplied, use it, else new __intbuf_
      if (!__owns_eb_ && __extbuf_ != __extbuf_min_) {
        __ibs_ = __ebs_;
        __intbuf_ = (char_type*)__extbuf_;
        __owns_ib_ = false;
        __extbuf_ = new char[__ebs_];
        __owns_eb_ = true;
      } else {
        __ibs_ = __ebs_;
        __intbuf_ = new char_type[__ibs_];
        __owns_ib_ = true;
      }
    }
  }
}

template<class charT, class traits>
bool basic_filebuf<charT, traits>::__read_mode() {
  if (!(__cm_ & std::ios_base::in)) {
    this->setp(nullptr, nullptr);
    if (__always_noconv_) {
      this->setg((char_type*)__extbuf_, (char_type*)__extbuf_ + __ebs_,
                 (char_type*)__extbuf_ + __ebs_);
    } else {
      this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);
    }
    __cm_ = std::ios_base::in;
    return true;
  }
  return false;
}

template<class charT, class traits>
void basic_filebuf<charT, traits>::__write_mode() {
  if (!(__cm_ & std::ios_base::out)) {
    this->setg(nullptr, nullptr, nullptr);
    if (__ebs_ > sizeof(__extbuf_min_)) {
      if (__always_noconv_) {
        this->setp((char_type*)__extbuf_, (char_type*)__extbuf_ + (__ebs_ - 1));
      } else {
        this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));
      }
    } else {
      this->setp(nullptr, nullptr);
    }
    __cm_ = std::ios_base::out;
  }
}    // NOLINTEND
}    // namespace tmp

#endif    // TMP_FILEBUF_H

#ifndef TMP_FILE_H
#define TMP_FILE_H

#include <tmp/export>

#include <filesystem>
#include <fstream>
#include <ios>
#include <istream>

#ifdef __GLIBCXX__
#include <ext/stdio_filebuf.h>
#endif

namespace tmp {

/// `tmp::file` is a smart handle that owns and manages a temporary file and
/// deletes it when this handle goes out of scope
///
/// When a `tmp::file` object is created, it creates a unique temporary file
/// using the system default location for temporary files and opens it
/// with the given `openmode`
///
/// The managed file is deleted of when either of the following happens:
/// - the managing `tmp::file` object is destroyed
/// - the managing `tmp::file` object is assigned another path via `operator=`
///
/// `tmp::file` extends the `std::iostream` class and uses an instance
/// of `std::filebuf` internally. It is essentially `std::fstream`
/// without open/close methods
///
/// The following example uses a `tmp::file` object to create a temporary file
/// and write a string to it; when the function returns, the `tmp::file` object
/// goes out of scope and the temporary file is deleted:
///
/// @code{.cpp}
///   #include <tmp/file>
///
///   auto func(std::string_view content) {
///     auto tmpfile = tmp::file(std::ios::bin);
///     tmpfile << content << std::flush;
///
///     // the temporary file is deleted recursively when the
///     // `tmp::file` object goes out of scope and is destroyed
///   }
/// @endcode
class TMP_EXPORT file : public std::iostream {
public:
  /// Implementation-defined handle type to the file
#if defined(_WIN32)
  using native_handle_type = void*;    // HANDLE
#elif __has_include(<unistd.h>)
  using native_handle_type = int;    // POSIX file descriptor
#else
#error "Target platform not supported"
#endif

  /// Creates a unique temporary file and opens it for reading and writing
  /// @note std::ios::in | std::ios::out are always added to the `mode`
  /// @param mode Specifies stream open mode
  /// @throws std::filesystem::filesystem_error if cannot create a file
  explicit file(std::ios::openmode mode = std::ios::in | std::ios::out);

  /// Creates a unique temporary copy from the given path
  /// @note std::ios::in | std::ios::out are always added to the `mode`
  /// @note after creating a copy, its I/O position indicator points to the end
  /// @param path A path to make a temporary copy from
  /// @param mode Specifies stream open mode
  /// @returns The new temporary file
  /// @throws std::filesystem::filesystem_error if given path is not a file
  static file copy(const std::filesystem::path& path,
                   std::ios::openmode mode = std::ios::in | std::ios::out);

  /// Returns an implementation-defined handle to this file
  /// @returns The underlying implementation-defined handle
  native_handle_type native_handle() const noexcept;

  /// Returns the path to this file
  /// @note The path is valid only within this process and its children
  /// @returns The full path to this file
  std::filesystem::path path() const;

  /// Moves the managed file to a given target, releasing
  /// ownership of the managed file; behaves like `std::filesystem::rename`
  /// even when moving between filesystems
  /// @param to A path to the target file
  /// @throws std::filesystem::filesystem_error if cannot move the owned file
  void move(const std::filesystem::path& to);

  /// Deletes and closes the managed file
  ~file() noexcept override;

  file(file&&) noexcept;                    ///< MoveConstructible
  file& operator=(file&&);                  ///< MoveAssignable
  file(const file&) = delete;               ///< not CopyConstructible
  file& operator=(const file&) = delete;    ///< not CopyAssignable

private:
#if defined(__GLIBCXX__)
  // In GNU libstdc++ we can just use the `__gnu_cxx::stdio_filebuf` extension,
  // which has everything we need

  /// The underlying raw file device object
  mutable __gnu_cxx::stdio_filebuf<char> sb;
#elif defined(_LIBCPP_VERSION)
  // In LLVM libc++ we use the public `std::filebuf::__open` method
  // and save a native handle to return in `file::native_handle()`

  /// The underlying native handle to the file
  int handle;

  /// The underlying raw file device object
  std::filebuf sb;
#elif defined(_MSC_VER)
  // In Microsoft STL we use the `std::filebuf::filebuf(std::FILE*)`
  // extension and save a pointer to that file to close it ourselves

  /// The underlying C file stream
  std::unique_ptr<std::FILE, decltype(&std::fclose)> underlying;

  /// The underlying raw file device object
  std::filebuf sb;
#else
#error "Target platform not supported"
#endif
};
}    // namespace tmp

/// The template specialization of `std::hash` for `tmp::file`
template<> struct TMP_EXPORT std::hash<tmp::file> {
  std::size_t operator()(const tmp::file& file) const noexcept;
};

#endif    // TMP_FILE_H

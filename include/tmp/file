// -*- C++ -*-
//
// SPDX-FileCopyrightText: (c) 2024 Ilya Andreev <bugdealer@icloud.com>
// SPDX-License-Identifier: MIT

#ifndef TMP_FILE_H
#define TMP_FILE_H

#include <cstddef>
#include <cstdio>
#include <filesystem>
#include <fstream>
#include <ios>
#include <istream>
#include <memory>
#include <system_error>

#ifdef __GLIBCXX__
#include <ext/stdio_filebuf.h>
#endif

namespace tmp {

namespace detail {
extern "C++" std::FILE* create_file(std::error_code& ec) noexcept;
#if defined(_WIN32)
extern "C++" void* get_native_handle(std::FILE* file) noexcept;
#elif __has_include(<unistd.h>)
extern "C++" int get_native_handle(std::FILE* file) noexcept;
#endif
}    // namespace detail

/// tmp::file is a smart handle that manages a binary temporary file, ensuring
/// its deletion when the handle goes out of scope
///
/// Upon creation, a tmp::file object generates a unique temporary file,
/// opening it for reading and writing in binary format
///
/// The temporary file is deleted of when either of the following happens:
/// - the tmp::file object is destroyed
/// - the tmp::file object is assigned another file using operator=
///
/// tmp::file inherits from the std::iostream class, allowing it to be
/// used seamlessly with standard input/output operations and simplifying file
/// handling while maintaining the flexibility of stream operations
///
/// The example below demonstrates a usage of a `tmp::file` object to validate
/// a request content and then unarchive it to persistent storage:
///
/// @code{.cpp}
///   #include <tmp/file>
///
///   auto func(std::string_view content) {
///     auto tmpfile = tmp::file();
///     tmpfile << contents << std::flush;
///     if (validate(tmpfile)) {
///       // Unarchive the file to the persistent storage
///       archive::unzip(tmpfile, storage);
///     } else {
///       // The file is deleted automatically
///       throw InvalidRequestError();
///     }
///   }
/// @endcode
template<class charT, class traits = std::char_traits<charT>>
class basic_file : public std::basic_iostream<charT, traits> {
public:
  using char_type   = charT;
  using int_type    = typename traits::int_type;
  using pos_type    = typename traits::pos_type;
  using off_type    = typename traits::off_type;
  using traits_type = traits;

  /// Implementation-defined handle type to the file
  using native_handle_type =
      std::invoke_result_t<decltype(detail::get_native_handle), std::FILE*>;

  /// Creates and opens a binary temporary file as if by POSIX `tmpfile`
  /// @throws std::filesystem::filesystem_error if cannot create a file
  explicit basic_file()
      : std::basic_iostream<charT, traits>(std::addressof(sb)),
        underlying(create_file_or_throw(), &std::fclose),
        sb(open_filebuf(underlying.get())) {}

  basic_file(const basic_file&)            = delete;
  basic_file& operator=(const basic_file&) = delete;

  /// Moves the ownership of the file managed by `other` to a new handle
  /// @note After the move, `other` is not associated with a file
  /// @param other Another file that will be moved from
  basic_file(basic_file&& other) noexcept
      : std::basic_iostream<charT, traits>(std::move(other)),
        underlying(std::move(other.underlying)),
        sb(std::move(other.sb)) {
    std::basic_iostream<charT, traits>::set_rdbuf(std::addressof(sb));
  }

  /// Deletes and closes the managed temporary file, then moves the ownership
  /// of the file managed by `other` to `this`
  /// @note After the assignment, `other` is not associated with a file
  /// @param other Another file that will be moved from
  /// @returns `*this`
  basic_file& operator=(basic_file&& other) = default;

  /// Returns an implementation-defined handle to this file
  /// @returns The underlying implementation-defined handle
  native_handle_type native_handle() const noexcept {
    return detail::get_native_handle(underlying.get());
  }

  /// Closes and deletes this file
  ~basic_file() noexcept override = default;

private:
  static std::FILE* create_file_or_throw() {
    std::error_code ec;
    std::FILE* f = detail::create_file(ec);
    if (ec) {
      throw std::filesystem::filesystem_error("Cannot create a temporary file",
                                              ec);
    }
    return f;
  }

  /// The underlying C file stream
  std::unique_ptr<std::FILE, int (*)(std::FILE*)> underlying;

#ifdef __GLIBCXX__
  /// The underlying raw file device object
  mutable __gnu_cxx::stdio_filebuf<charT, traits> sb;
#else
  /// The underlying raw file device object
  std::basic_filebuf<charT, traits> sb;
#endif

  /// Returns a file device for the given file stream
  /// @param file The file stream
  /// @returns The new file device
  /// @throws std::filesystem::filesystem_error if cannot open the file stream
  static decltype(sb) open_filebuf(std::FILE* file) {
    constexpr auto mode = std::ios::binary | std::ios::in | std::ios::out;
    decltype(sb) sb;
#if defined(_MSC_VER)
    sb = std::basic_filebuf<charT, traits>(file);
#elif defined(_LIBCPP_VERSION)
    sb.__open(detail::get_native_handle(file), mode);
#else
    sb = __gnu_cxx::stdio_filebuf<charT, traits>(file, mode);
#endif

    if (!sb.is_open()) {
      std::error_code ec = std::make_error_code(std::io_errc::stream);
      throw std::filesystem::filesystem_error("Cannot create a temporary file",
                                              ec);
    }

    return sb;
  }
};

using file  = basic_file<char>;
using wfile = basic_file<wchar_t>;
}    // namespace tmp

#endif    // TMP_FILE_H
